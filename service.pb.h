// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: service.proto

#ifndef PROTOBUF_service_2eproto__INCLUDED
#define PROTOBUF_service_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_service_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[2];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsRenderRequestImpl();
void InitDefaultsRenderRequest();
void InitDefaultsRenderResponseImpl();
void InitDefaultsRenderResponse();
inline void InitDefaults() {
  InitDefaultsRenderRequest();
  InitDefaultsRenderResponse();
}
}  // namespace protobuf_service_2eproto
namespace visma {
namespace pdfutil {
class RenderRequest;
class RenderRequestDefaultTypeInternal;
extern RenderRequestDefaultTypeInternal _RenderRequest_default_instance_;
class RenderResponse;
class RenderResponseDefaultTypeInternal;
extern RenderResponseDefaultTypeInternal _RenderResponse_default_instance_;
}  // namespace pdfutil
}  // namespace visma
namespace visma {
namespace pdfutil {

enum ImageType {
  ARGB = 0,
  BINARY = 1,
  GRAY = 2,
  RGB = 3,
  ImageType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ImageType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ImageType_IsValid(int value);
const ImageType ImageType_MIN = ARGB;
const ImageType ImageType_MAX = RGB;
const int ImageType_ARRAYSIZE = ImageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ImageType_descriptor();
inline const ::std::string& ImageType_Name(ImageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ImageType_descriptor(), value);
}
inline bool ImageType_Parse(
    const ::std::string& name, ImageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ImageType>(
    ImageType_descriptor(), name, value);
}
enum ImageFormat {
  PNG = 0,
  PPM = 1,
  ImageFormat_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ImageFormat_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ImageFormat_IsValid(int value);
const ImageFormat ImageFormat_MIN = PNG;
const ImageFormat ImageFormat_MAX = PPM;
const int ImageFormat_ARRAYSIZE = ImageFormat_MAX + 1;

const ::google::protobuf::EnumDescriptor* ImageFormat_descriptor();
inline const ::std::string& ImageFormat_Name(ImageFormat value) {
  return ::google::protobuf::internal::NameOfEnum(
    ImageFormat_descriptor(), value);
}
inline bool ImageFormat_Parse(
    const ::std::string& name, ImageFormat* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ImageFormat>(
    ImageFormat_descriptor(), name, value);
}
// ===================================================================

class RenderRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:visma.pdfutil.RenderRequest) */ {
 public:
  RenderRequest();
  virtual ~RenderRequest();

  RenderRequest(const RenderRequest& from);

  inline RenderRequest& operator=(const RenderRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RenderRequest(RenderRequest&& from) noexcept
    : RenderRequest() {
    *this = ::std::move(from);
  }

  inline RenderRequest& operator=(RenderRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RenderRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RenderRequest* internal_default_instance() {
    return reinterpret_cast<const RenderRequest*>(
               &_RenderRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(RenderRequest* other);
  friend void swap(RenderRequest& a, RenderRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RenderRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  RenderRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RenderRequest& from);
  void MergeFrom(const RenderRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RenderRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 targetPages = 2;
  int targetpages_size() const;
  void clear_targetpages();
  static const int kTargetPagesFieldNumber = 2;
  ::google::protobuf::int32 targetpages(int index) const;
  void set_targetpages(int index, ::google::protobuf::int32 value);
  void add_targetpages(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      targetpages() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_targetpages();

  // bytes pdfData = 1;
  void clear_pdfdata();
  static const int kPdfDataFieldNumber = 1;
  const ::std::string& pdfdata() const;
  void set_pdfdata(const ::std::string& value);
  #if LANG_CXX11
  void set_pdfdata(::std::string&& value);
  #endif
  void set_pdfdata(const char* value);
  void set_pdfdata(const void* value, size_t size);
  ::std::string* mutable_pdfdata();
  ::std::string* release_pdfdata();
  void set_allocated_pdfdata(::std::string* pdfdata);

  // int32 DPI = 3;
  void clear_dpi();
  static const int kDPIFieldNumber = 3;
  ::google::protobuf::int32 dpi() const;
  void set_dpi(::google::protobuf::int32 value);

  // .visma.pdfutil.ImageType imageType = 4;
  void clear_imagetype();
  static const int kImageTypeFieldNumber = 4;
  ::visma::pdfutil::ImageType imagetype() const;
  void set_imagetype(::visma::pdfutil::ImageType value);

  // .visma.pdfutil.ImageFormat imageFormat = 5;
  void clear_imageformat();
  static const int kImageFormatFieldNumber = 5;
  ::visma::pdfutil::ImageFormat imageformat() const;
  void set_imageformat(::visma::pdfutil::ImageFormat value);

  // bool extractText = 6;
  void clear_extracttext();
  static const int kExtractTextFieldNumber = 6;
  bool extracttext() const;
  void set_extracttext(bool value);

  // @@protoc_insertion_point(class_scope:visma.pdfutil.RenderRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > targetpages_;
  mutable int _targetpages_cached_byte_size_;
  ::google::protobuf::internal::ArenaStringPtr pdfdata_;
  ::google::protobuf::int32 dpi_;
  int imagetype_;
  int imageformat_;
  bool extracttext_;
  mutable int _cached_size_;
  friend struct ::protobuf_service_2eproto::TableStruct;
  friend void ::protobuf_service_2eproto::InitDefaultsRenderRequestImpl();
};
// -------------------------------------------------------------------

class RenderResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:visma.pdfutil.RenderResponse) */ {
 public:
  RenderResponse();
  virtual ~RenderResponse();

  RenderResponse(const RenderResponse& from);

  inline RenderResponse& operator=(const RenderResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RenderResponse(RenderResponse&& from) noexcept
    : RenderResponse() {
    *this = ::std::move(from);
  }

  inline RenderResponse& operator=(RenderResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RenderResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RenderResponse* internal_default_instance() {
    return reinterpret_cast<const RenderResponse*>(
               &_RenderResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(RenderResponse* other);
  friend void swap(RenderResponse& a, RenderResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RenderResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  RenderResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RenderResponse& from);
  void MergeFrom(const RenderResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RenderResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string pageText = 2;
  void clear_pagetext();
  static const int kPageTextFieldNumber = 2;
  const ::std::string& pagetext() const;
  void set_pagetext(const ::std::string& value);
  #if LANG_CXX11
  void set_pagetext(::std::string&& value);
  #endif
  void set_pagetext(const char* value);
  void set_pagetext(const char* value, size_t size);
  ::std::string* mutable_pagetext();
  ::std::string* release_pagetext();
  void set_allocated_pagetext(::std::string* pagetext);

  // bytes imageData = 3;
  void clear_imagedata();
  static const int kImageDataFieldNumber = 3;
  const ::std::string& imagedata() const;
  void set_imagedata(const ::std::string& value);
  #if LANG_CXX11
  void set_imagedata(::std::string&& value);
  #endif
  void set_imagedata(const char* value);
  void set_imagedata(const void* value, size_t size);
  ::std::string* mutable_imagedata();
  ::std::string* release_imagedata();
  void set_allocated_imagedata(::std::string* imagedata);

  // int32 pageIndex = 1;
  void clear_pageindex();
  static const int kPageIndexFieldNumber = 1;
  ::google::protobuf::int32 pageindex() const;
  void set_pageindex(::google::protobuf::int32 value);

  // int32 imageHeight = 4;
  void clear_imageheight();
  static const int kImageHeightFieldNumber = 4;
  ::google::protobuf::int32 imageheight() const;
  void set_imageheight(::google::protobuf::int32 value);

  // int32 imageWidth = 5;
  void clear_imagewidth();
  static const int kImageWidthFieldNumber = 5;
  ::google::protobuf::int32 imagewidth() const;
  void set_imagewidth(::google::protobuf::int32 value);

  // int32 imageDPI = 6;
  void clear_imagedpi();
  static const int kImageDPIFieldNumber = 6;
  ::google::protobuf::int32 imagedpi() const;
  void set_imagedpi(::google::protobuf::int32 value);

  // .visma.pdfutil.ImageFormat imageFormat = 7;
  void clear_imageformat();
  static const int kImageFormatFieldNumber = 7;
  ::visma::pdfutil::ImageFormat imageformat() const;
  void set_imageformat(::visma::pdfutil::ImageFormat value);

  // int32 imageSize = 8;
  void clear_imagesize();
  static const int kImageSizeFieldNumber = 8;
  ::google::protobuf::int32 imagesize() const;
  void set_imagesize(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:visma.pdfutil.RenderResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr pagetext_;
  ::google::protobuf::internal::ArenaStringPtr imagedata_;
  ::google::protobuf::int32 pageindex_;
  ::google::protobuf::int32 imageheight_;
  ::google::protobuf::int32 imagewidth_;
  ::google::protobuf::int32 imagedpi_;
  int imageformat_;
  ::google::protobuf::int32 imagesize_;
  mutable int _cached_size_;
  friend struct ::protobuf_service_2eproto::TableStruct;
  friend void ::protobuf_service_2eproto::InitDefaultsRenderResponseImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RenderRequest

// bytes pdfData = 1;
inline void RenderRequest::clear_pdfdata() {
  pdfdata_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RenderRequest::pdfdata() const {
  // @@protoc_insertion_point(field_get:visma.pdfutil.RenderRequest.pdfData)
  return pdfdata_.GetNoArena();
}
inline void RenderRequest::set_pdfdata(const ::std::string& value) {
  
  pdfdata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:visma.pdfutil.RenderRequest.pdfData)
}
#if LANG_CXX11
inline void RenderRequest::set_pdfdata(::std::string&& value) {
  
  pdfdata_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:visma.pdfutil.RenderRequest.pdfData)
}
#endif
inline void RenderRequest::set_pdfdata(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  pdfdata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:visma.pdfutil.RenderRequest.pdfData)
}
inline void RenderRequest::set_pdfdata(const void* value, size_t size) {
  
  pdfdata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:visma.pdfutil.RenderRequest.pdfData)
}
inline ::std::string* RenderRequest::mutable_pdfdata() {
  
  // @@protoc_insertion_point(field_mutable:visma.pdfutil.RenderRequest.pdfData)
  return pdfdata_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RenderRequest::release_pdfdata() {
  // @@protoc_insertion_point(field_release:visma.pdfutil.RenderRequest.pdfData)
  
  return pdfdata_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RenderRequest::set_allocated_pdfdata(::std::string* pdfdata) {
  if (pdfdata != NULL) {
    
  } else {
    
  }
  pdfdata_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pdfdata);
  // @@protoc_insertion_point(field_set_allocated:visma.pdfutil.RenderRequest.pdfData)
}

// repeated int32 targetPages = 2;
inline int RenderRequest::targetpages_size() const {
  return targetpages_.size();
}
inline void RenderRequest::clear_targetpages() {
  targetpages_.Clear();
}
inline ::google::protobuf::int32 RenderRequest::targetpages(int index) const {
  // @@protoc_insertion_point(field_get:visma.pdfutil.RenderRequest.targetPages)
  return targetpages_.Get(index);
}
inline void RenderRequest::set_targetpages(int index, ::google::protobuf::int32 value) {
  targetpages_.Set(index, value);
  // @@protoc_insertion_point(field_set:visma.pdfutil.RenderRequest.targetPages)
}
inline void RenderRequest::add_targetpages(::google::protobuf::int32 value) {
  targetpages_.Add(value);
  // @@protoc_insertion_point(field_add:visma.pdfutil.RenderRequest.targetPages)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
RenderRequest::targetpages() const {
  // @@protoc_insertion_point(field_list:visma.pdfutil.RenderRequest.targetPages)
  return targetpages_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
RenderRequest::mutable_targetpages() {
  // @@protoc_insertion_point(field_mutable_list:visma.pdfutil.RenderRequest.targetPages)
  return &targetpages_;
}

// int32 DPI = 3;
inline void RenderRequest::clear_dpi() {
  dpi_ = 0;
}
inline ::google::protobuf::int32 RenderRequest::dpi() const {
  // @@protoc_insertion_point(field_get:visma.pdfutil.RenderRequest.DPI)
  return dpi_;
}
inline void RenderRequest::set_dpi(::google::protobuf::int32 value) {
  
  dpi_ = value;
  // @@protoc_insertion_point(field_set:visma.pdfutil.RenderRequest.DPI)
}

// .visma.pdfutil.ImageType imageType = 4;
inline void RenderRequest::clear_imagetype() {
  imagetype_ = 0;
}
inline ::visma::pdfutil::ImageType RenderRequest::imagetype() const {
  // @@protoc_insertion_point(field_get:visma.pdfutil.RenderRequest.imageType)
  return static_cast< ::visma::pdfutil::ImageType >(imagetype_);
}
inline void RenderRequest::set_imagetype(::visma::pdfutil::ImageType value) {
  
  imagetype_ = value;
  // @@protoc_insertion_point(field_set:visma.pdfutil.RenderRequest.imageType)
}

// .visma.pdfutil.ImageFormat imageFormat = 5;
inline void RenderRequest::clear_imageformat() {
  imageformat_ = 0;
}
inline ::visma::pdfutil::ImageFormat RenderRequest::imageformat() const {
  // @@protoc_insertion_point(field_get:visma.pdfutil.RenderRequest.imageFormat)
  return static_cast< ::visma::pdfutil::ImageFormat >(imageformat_);
}
inline void RenderRequest::set_imageformat(::visma::pdfutil::ImageFormat value) {
  
  imageformat_ = value;
  // @@protoc_insertion_point(field_set:visma.pdfutil.RenderRequest.imageFormat)
}

// bool extractText = 6;
inline void RenderRequest::clear_extracttext() {
  extracttext_ = false;
}
inline bool RenderRequest::extracttext() const {
  // @@protoc_insertion_point(field_get:visma.pdfutil.RenderRequest.extractText)
  return extracttext_;
}
inline void RenderRequest::set_extracttext(bool value) {
  
  extracttext_ = value;
  // @@protoc_insertion_point(field_set:visma.pdfutil.RenderRequest.extractText)
}

// -------------------------------------------------------------------

// RenderResponse

// int32 pageIndex = 1;
inline void RenderResponse::clear_pageindex() {
  pageindex_ = 0;
}
inline ::google::protobuf::int32 RenderResponse::pageindex() const {
  // @@protoc_insertion_point(field_get:visma.pdfutil.RenderResponse.pageIndex)
  return pageindex_;
}
inline void RenderResponse::set_pageindex(::google::protobuf::int32 value) {
  
  pageindex_ = value;
  // @@protoc_insertion_point(field_set:visma.pdfutil.RenderResponse.pageIndex)
}

// string pageText = 2;
inline void RenderResponse::clear_pagetext() {
  pagetext_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RenderResponse::pagetext() const {
  // @@protoc_insertion_point(field_get:visma.pdfutil.RenderResponse.pageText)
  return pagetext_.GetNoArena();
}
inline void RenderResponse::set_pagetext(const ::std::string& value) {
  
  pagetext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:visma.pdfutil.RenderResponse.pageText)
}
#if LANG_CXX11
inline void RenderResponse::set_pagetext(::std::string&& value) {
  
  pagetext_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:visma.pdfutil.RenderResponse.pageText)
}
#endif
inline void RenderResponse::set_pagetext(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  pagetext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:visma.pdfutil.RenderResponse.pageText)
}
inline void RenderResponse::set_pagetext(const char* value, size_t size) {
  
  pagetext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:visma.pdfutil.RenderResponse.pageText)
}
inline ::std::string* RenderResponse::mutable_pagetext() {
  
  // @@protoc_insertion_point(field_mutable:visma.pdfutil.RenderResponse.pageText)
  return pagetext_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RenderResponse::release_pagetext() {
  // @@protoc_insertion_point(field_release:visma.pdfutil.RenderResponse.pageText)
  
  return pagetext_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RenderResponse::set_allocated_pagetext(::std::string* pagetext) {
  if (pagetext != NULL) {
    
  } else {
    
  }
  pagetext_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pagetext);
  // @@protoc_insertion_point(field_set_allocated:visma.pdfutil.RenderResponse.pageText)
}

// bytes imageData = 3;
inline void RenderResponse::clear_imagedata() {
  imagedata_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RenderResponse::imagedata() const {
  // @@protoc_insertion_point(field_get:visma.pdfutil.RenderResponse.imageData)
  return imagedata_.GetNoArena();
}
inline void RenderResponse::set_imagedata(const ::std::string& value) {
  
  imagedata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:visma.pdfutil.RenderResponse.imageData)
}
#if LANG_CXX11
inline void RenderResponse::set_imagedata(::std::string&& value) {
  
  imagedata_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:visma.pdfutil.RenderResponse.imageData)
}
#endif
inline void RenderResponse::set_imagedata(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  imagedata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:visma.pdfutil.RenderResponse.imageData)
}
inline void RenderResponse::set_imagedata(const void* value, size_t size) {
  
  imagedata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:visma.pdfutil.RenderResponse.imageData)
}
inline ::std::string* RenderResponse::mutable_imagedata() {
  
  // @@protoc_insertion_point(field_mutable:visma.pdfutil.RenderResponse.imageData)
  return imagedata_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RenderResponse::release_imagedata() {
  // @@protoc_insertion_point(field_release:visma.pdfutil.RenderResponse.imageData)
  
  return imagedata_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RenderResponse::set_allocated_imagedata(::std::string* imagedata) {
  if (imagedata != NULL) {
    
  } else {
    
  }
  imagedata_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), imagedata);
  // @@protoc_insertion_point(field_set_allocated:visma.pdfutil.RenderResponse.imageData)
}

// int32 imageHeight = 4;
inline void RenderResponse::clear_imageheight() {
  imageheight_ = 0;
}
inline ::google::protobuf::int32 RenderResponse::imageheight() const {
  // @@protoc_insertion_point(field_get:visma.pdfutil.RenderResponse.imageHeight)
  return imageheight_;
}
inline void RenderResponse::set_imageheight(::google::protobuf::int32 value) {
  
  imageheight_ = value;
  // @@protoc_insertion_point(field_set:visma.pdfutil.RenderResponse.imageHeight)
}

// int32 imageWidth = 5;
inline void RenderResponse::clear_imagewidth() {
  imagewidth_ = 0;
}
inline ::google::protobuf::int32 RenderResponse::imagewidth() const {
  // @@protoc_insertion_point(field_get:visma.pdfutil.RenderResponse.imageWidth)
  return imagewidth_;
}
inline void RenderResponse::set_imagewidth(::google::protobuf::int32 value) {
  
  imagewidth_ = value;
  // @@protoc_insertion_point(field_set:visma.pdfutil.RenderResponse.imageWidth)
}

// int32 imageDPI = 6;
inline void RenderResponse::clear_imagedpi() {
  imagedpi_ = 0;
}
inline ::google::protobuf::int32 RenderResponse::imagedpi() const {
  // @@protoc_insertion_point(field_get:visma.pdfutil.RenderResponse.imageDPI)
  return imagedpi_;
}
inline void RenderResponse::set_imagedpi(::google::protobuf::int32 value) {
  
  imagedpi_ = value;
  // @@protoc_insertion_point(field_set:visma.pdfutil.RenderResponse.imageDPI)
}

// .visma.pdfutil.ImageFormat imageFormat = 7;
inline void RenderResponse::clear_imageformat() {
  imageformat_ = 0;
}
inline ::visma::pdfutil::ImageFormat RenderResponse::imageformat() const {
  // @@protoc_insertion_point(field_get:visma.pdfutil.RenderResponse.imageFormat)
  return static_cast< ::visma::pdfutil::ImageFormat >(imageformat_);
}
inline void RenderResponse::set_imageformat(::visma::pdfutil::ImageFormat value) {
  
  imageformat_ = value;
  // @@protoc_insertion_point(field_set:visma.pdfutil.RenderResponse.imageFormat)
}

// int32 imageSize = 8;
inline void RenderResponse::clear_imagesize() {
  imagesize_ = 0;
}
inline ::google::protobuf::int32 RenderResponse::imagesize() const {
  // @@protoc_insertion_point(field_get:visma.pdfutil.RenderResponse.imageSize)
  return imagesize_;
}
inline void RenderResponse::set_imagesize(::google::protobuf::int32 value) {
  
  imagesize_ = value;
  // @@protoc_insertion_point(field_set:visma.pdfutil.RenderResponse.imageSize)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pdfutil
}  // namespace visma

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::visma::pdfutil::ImageType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::visma::pdfutil::ImageType>() {
  return ::visma::pdfutil::ImageType_descriptor();
}
template <> struct is_proto_enum< ::visma::pdfutil::ImageFormat> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::visma::pdfutil::ImageFormat>() {
  return ::visma::pdfutil::ImageFormat_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_service_2eproto__INCLUDED
